#!/usr/bin/env bash

set -euo pipefail

# BlobeVM Manager CLI
# Commands:
#   list
#   create <name>
#   start <name>
#   stop <name>
#   restart <name>
#   status <name>
#   check [--no-fix] <name>   # HTTP check the VM URL; optional --no-fix to skip auto-resolve
#   delete <name>
#   rename <old> <new>        # move instance and switch URL to new name
#   set-host <name> <fqdn>    # override host (domain mode): e.g., vm1.example.com
#   clear-host <name>         # remove host override and return to name.<domain>
#   set-path <name> </prefix> # override path (no-domain mode), e.g., /desk/1
#   clear-path <name>         # remove path override and return to /vm/<name>
#   nuke                      # uninstall everything created by server/install.sh
#   set-host-interactive <name>  # prompts & prints IPs, then asks for host
#   set-base-path </base>         # set global base path (default /vm)
#   clear-base-path               # revert global base path to /vm
#   set-limits <name> <cpu> <mem>  # set CPU (e.g. 0.5 or 2) and memory (e.g. 1g, 512m)
#   clear-limits <name>            # remove resource limits
#   rebuild-image                  # docker build image from REPO_DIR
#   recreate-all                   # recreate all VM containers with current image
#   recreate <name> [name2 ...]    # recreate only specific VMs
#   rebuild-all                    # rebuild-image + recreate-all
#   rebuild-vms <name> [name2..]   # rebuild image then recreate only these VMs
#   pull-repo                      # git pull in REPO_DIR (if repo)
#   update-and-rebuild             # pull-repo + rebuild-all
#   delete-all-instances           # delete all VMs (containers and data) but keep stack/image
# - In Traefik mode: creates per-instance containers on network "proxy" and routes via Traefik
# - In Direct mode (NO_TRAEFIK=1): publishes a unique high port per VM without any reverse proxy
# - Prints the VM URL on create/start

STATE_DIR=/opt/blobe-vm
INST_DIR="$STATE_DIR/instances"
ENV_FILE="$STATE_DIR/.env"

# Directory for cloudflared configs when running containerized fallback
CF_STATE_DIR="$STATE_DIR/.cloudflared"

ensure_cloudflared_state_dir() {
  mkdir -p "$CF_STATE_DIR"
}

# Run cloudflared as a docker container (fallback when systemd not available)
run_cloudflared_container() {
  # args: container-name image-args...
  local cname="$1"; shift
  # Remove existing container
  docker rm -f "$cname" >/dev/null 2>&1 || true
  # Run with host networking so local backends (127.0.0.1:port) are reachable
  docker run -d --name "$cname" --net host --restart unless-stopped \
    -v "$CF_STATE_DIR":/etc/cloudflared:rw \
    cloudflare/cloudflared:latest "$@" >/dev/null 2>&1 || return 1
  return 0
}

resolve_public_host() {
  # Resolve the public/external host for backend URLs.
  # Priority: PUBLIC_HOST env > first non-Docker IP from hostname -I > localhost
  # Avoid Docker bridge IPs (172.x.x.x, 10.x.x.x unless it's the primary one)
  if [[ -n "${PUBLIC_HOST:-}" ]]; then
    echo "$PUBLIC_HOST"
    return 0
  fi
  # Try to get first non-Docker IP
  if command -v hostname >/dev/null 2>&1; then
    local ips
    ips=$(hostname -I 2>/dev/null || true)
    for ip in $ips; do
      # Skip Docker bridge IPs (typically 172.17-31.x.x or 10.x.x.x)
      if [[ ! "$ip" =~ ^172\.(1[7-9]|2[0-9]|3[0-1])\. ]] && [[ ! "$ip" =~ ^10\. ]]; then
        echo "$ip"
        return 0
      fi
    done
    # If all IPs are Docker-ish, return the first one anyway (better than nothing)
    if [[ -n "$ips" ]]; then
      echo $ips | awk '{print $1}'
      return 0
    fi
  fi
  echo "127.0.0.1"
}

use_systemd() {
  # Return 0 if systemctl is present and appears usable
  if command -v systemctl >/dev/null 2>&1 && [[ $EUID -eq 0 ]]; then
    return 0
  fi
  return 1
}

if [[ -f "$ENV_FILE" ]]; then
  # shellcheck disable=SC1090,SC2155
  while IFS='=' read -r k v; do
    [[ -z "$k" || "$k" =~ ^# ]] && continue
    # Remove surrounding single or double quotes
    v="${v%\'}"; v="${v#\'}"; v="${v%\"}"; v="${v#\"}"
    export "$k"="$v"
  done < "$ENV_FILE"
fi

# Defaults for direct mode
NO_TRAEFIK=${NO_TRAEFIK:-0}
DIRECT_PORT_START=${DIRECT_PORT_START:-20000}

# --- Port helpers (for direct mode) ---
port_in_use() {
  local p="$1"
  # If Docker is available (typical when manager runs inside dashboard), check published ports first
  if command -v docker >/dev/null 2>&1; then
    # Look for bindings like 0.0.0.0:p-> or :::p-> in the Ports column
    if docker ps --format '{{.Ports}}' | grep -E "(^|[, ])(0\.0\.0\.0|:::)?${p}->" >/dev/null 2>&1; then
      return 0
    fi
  fi
  # Fallback to socket listeners (works when running on the host)
  if command -v ss >/dev/null 2>&1; then
    ss -ltn | awk '{print $4}' | grep -E "(^|:)${p}$" >/dev/null 2>&1 && return 0
  elif command -v netstat >/dev/null 2>&1; then
    netstat -ltn 2>/dev/null | awk '{print $4}' | grep -E "(^|:)${p}$" >/dev/null 2>&1 && return 0
  fi
  return 1
}

find_free_port() {
  local start="$1"; local attempts="${2:-500}"; local p="$start"; local i=0
  while (( i < attempts )); do
    if ! port_in_use "$p"; then echo "$p"; return 0; fi
    p=$((p+1)); i=$((i+1))
  done
  return 1
}

usage() {
  cat >&2 <<USAGE
Usage: blobe-vm-manager <command> [args]

Commands:
  list
  list-ports                 # direct mode: show VM -> port
  create <name>
  start <name>
  stop <name>
  restart <name>
  status <name>              # print container status and URL
  check [--no-fix] <name>    # HTTP check the VM URL; optional --no-fix to skip auto-resolve
  delete <name>
  delete-all-instances       # delete all VM instances and containers (keeps image/stack)
  rename <old> <new>
  set-host <name> <fqdn>
  clear-host <name>
  set-path <name> </prefix>
  clear-path <name>
  port <name>                # direct mode: print assigned port
  set-port <name> <port>     # direct mode: set fixed port and recreate
  url <name>                 # print the VM URL
  open <name>                # try to open the VM URL using a local browser
  dashboard-url              # print the dashboard URL
  open-dashboard             # try to open the dashboard URL
  rebuild-image              # rebuild container image from REPO_DIR
  recreate-all               # recreate all VM containers using current image
  recreate <name> [name2..]  # recreate specific VMs using current image
  rebuild-all                # rebuild image and recreate all VMs
  rebuild-vms <name> [..]    # rebuild image then recreate specific VMs
  pull-repo                  # git pull in REPO_DIR (if a git repo)
  update-and-rebuild [vms..] # pull repo, rebuild image, recreate all or specified VMs
  update-vm <name>           # apt update/upgrade inside VM container
  app-install <name> <app>   # install an app inside the VM (if script exists)
  app-status <name> <app>    # check if an app binary exists in VM
  app-uninstall <name> <app> # uninstall/remove an app from the VM
  app-reinstall <name> <app> # uninstall then install the app
USAGE
  exit 1
}

ensure_instance_dir() {
  mkdir -p "$INST_DIR"
}

instance_exists() {
  local name="$1"
  [[ -d "$INST_DIR/$name" ]]
}

container_name() {
  local name="$1"
  echo "blobevm_${name}"
}

vm_url() {
  local name="$1"
  local host_override path_override
  host_override="$(get_meta "$name" host_override || true)"
  path_override="$(get_meta "$name" path_override || true)"
  local base_path="${BASE_PATH:-/vm}"
  [[ "$base_path" != /* ]] && base_path="/$base_path"
  base_path="${base_path%/}"
  local http_port="${HTTP_PORT:-80}"
  local https_port="${HTTPS_PORT:-443}"
  # Direct mode: show port-based URL
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    local host_port
    host_port="$(get_meta "$name" host_port || true)"
    if [[ -z "$host_port" ]]; then
      # Assign on demand
      host_port="$(find_free_port "${DIRECT_PORT_START}" 1000 || true)"
      if [[ -n "$host_port" ]]; then
        set_meta "$name" host_port "$host_port"
      else
        echo "<port-pending>"; return
      fi
    fi
    local host
    if [[ -n "$host_override" ]]; then
      host="$host_override"
    else
      host="$(resolve_public_host)"
    fi
    echo "http://${host}:${host_port}/"
    return
  fi
  # If a host override exists, prefer host-based URL even in no-domain mode
  if [[ -n "$host_override" ]]; then
    local scheme="http"
    [[ "${ENABLE_TLS:-0}" -eq 1 ]] && scheme="https"
    local port_suffix=""
    if [[ "$scheme" == "http" && "$http_port" != "80" ]]; then port_suffix=":$http_port"; fi
    if [[ "$scheme" == "https" && "$https_port" != "443" ]]; then port_suffix=":$https_port"; fi
    echo "${scheme}://${host_override}${port_suffix}/"
    return
  fi
  if [[ -n "${BLOBEVM_DOMAIN:-}" ]]; then
    local scheme="http"
    [[ "${ENABLE_TLS:-0}" -eq 1 ]] && scheme="https"
    local port_suffix=""
    if [[ "$scheme" == "http" && "$http_port" != "80" ]]; then port_suffix=":$http_port"; fi
    if [[ "$scheme" == "https" && "$https_port" != "443" ]]; then port_suffix=":$https_port"; fi
    echo "${scheme}://${name}.${BLOBEVM_DOMAIN}${port_suffix}/"
  else
    local ip
    ip="$(resolve_public_host)"
    local pfx
    if [[ -n "$path_override" ]]; then
      pfx="$path_override"
    else
      pfx="${base_path}/${name}/"
    fi
    # Ensure path has leading and trailing slash
    [[ "$pfx" != /* ]] && pfx="/$pfx"
    [[ "$pfx" != */ ]] && pfx="$pfx/"
    local port_suffix=""
    if [[ "$http_port" != "80" ]]; then port_suffix=":$http_port"; fi
    echo "http://$ip${port_suffix}${pfx}"
  fi
}

common_labels() {
  local name="$1"
  # In direct mode, no proxy labels are needed
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    return 0
  fi
  local host_override path_override
  host_override="$(get_meta "$name" host_override || true)"
  path_override="$(get_meta "$name" path_override || true)"
  local labels=()
  labels+=("--label=traefik.docker.network=${TRAEFIK_NETWORK:-proxy}")
  labels+=("--label=traefik.enable=true")

  if [[ -n "$host_override" ]]; then
    # Host override + dual path router
    local host "$host_override"
    local base_path="${BASE_PATH:-/vm}"; [[ "$base_path" != /* ]] && base_path="/$base_path"; base_path="${base_path%/}"
    local prefix_path
    if [[ -n "$path_override" ]]; then
      prefix_path="$path_override"
    else
      prefix_path="${base_path}/${name}"
    fi
    [[ "$prefix_path" != /* ]] && prefix_path="/$prefix_path"
    prefix_path="${prefix_path%/}"

    labels+=(
      "--label=traefik.http.routers.${name}.rule=Host(\`$host_override\`)"
      "--label=traefik.http.routers.${name}.entrypoints=web"
      "--label=traefik.http.services.${name}.loadbalancer.server.port=3000"
      "--label=traefik.http.routers.${name}-path.rule=PathPrefix(\`$prefix_path\`)"
      "--label=traefik.http.routers.${name}-path.entrypoints=web"
      "--label=traefik.http.services.${name}-path.loadbalancer.server.port=3000"
    )
    if [[ "${ENABLE_TLS:-0}" -eq 1 ]]; then
      # Add HTTPS routers; include certresolver only when TLS is enabled
      labels+=(
        "--label=traefik.http.routers.${name}-secure.rule=Host(\`$host_override\`)"
        "--label=traefik.http.routers.${name}-secure.entrypoints=websecure"
        "--label=traefik.http.routers.${name}-secure.tls=true"
        "--label=traefik.http.services.${name}.loadbalancer.server.port=3000"
        "--label=traefik.http.routers.${name}-path-secure.rule=PathPrefix(\`$prefix_path\`)"
        "--label=traefik.http.routers.${name}-path-secure.entrypoints=websecure"
        "--label=traefik.http.routers.${name}-path-secure.tls=true"
        "--label=traefik.http.services.${name}-path-secure.loadbalancer.server.port=3000"
      )
      labels+=(
        "--label=traefik.http.routers.${name}-secure.tls.certresolver=myresolver"
        "--label=traefik.http.routers.${name}-path-secure.tls.certresolver=myresolver"
      )
    fi
  elif [[ -n "${BLOBEVM_DOMAIN:-}" && "${MERGED_MODE:-0}" -ne 1 ]]; then
    # Domain mode: host router + path router
    local host="${name}.${BLOBEVM_DOMAIN}"
    local base_path="${BASE_PATH:-/vm}"; [[ "$base_path" != /* ]] && base_path="/$base_path"; base_path="${base_path%/}"
    local prefix_path="${base_path}/${name}"; [[ "$prefix_path" != /* ]] && prefix_path="/$prefix_path"; prefix_path="${prefix_path%/}"
    labels+=(
      "--label=traefik.http.routers.${name}.rule=Host(\`$host\`)"
      "--label=traefik.http.routers.${name}.entrypoints=web"
      "--label=traefik.http.services.${name}.loadbalancer.server.port=3000"
      "--label=traefik.http.routers.${name}-path.rule=PathPrefix(\`$prefix_path\`)"
      "--label=traefik.http.routers.${name}-path.entrypoints=web"
      "--label=traefik.http.services.${name}-path.loadbalancer.server.port=3000"
    )
    if [[ "${ENABLE_TLS:-0}" -eq 1 ]]; then
      labels+=(
        "--label=traefik.http.routers.${name}-secure.rule=Host(\`$host\`)"
        "--label=traefik.http.routers.${name}-secure.entrypoints=websecure"
        "--label=traefik.http.routers.${name}-secure.tls=true"
        "--label=traefik.http.services.${name}.loadbalancer.server.port=3000"
        "--label=traefik.http.routers.${name}-path-secure.rule=PathPrefix(\`$prefix_path\`)"
        "--label=traefik.http.routers.${name}-path-secure.entrypoints=websecure"
        "--label=traefik.http.routers.${name}-path-secure.tls=true"
        "--label=traefik.http.services.${name}-path-secure.loadbalancer.server.port=3000"
      )
      labels+=(
        "--label=traefik.http.routers.${name}-secure.tls.certresolver=myresolver"
        "--label=traefik.http.routers.${name}-path-secure.tls.certresolver=myresolver"
      )
    fi
  else
    # Path-based routing when no domain present
    local prefix
    if [[ -n "$path_override" ]]; then
      prefix="$path_override"
    else
      local base_path="${BASE_PATH:-/vm}"; [[ "$base_path" != /* ]] && base_path="/$base_path"; base_path="${base_path%/}"
      prefix="${base_path}/${name}"
    fi
    [[ "$prefix" != /* ]] && prefix="/$prefix"
    prefix="${prefix%/}"
    labels+=(
      "--label=traefik.http.routers.${name}.rule=PathPrefix(\`$prefix\`)"
      "--label=traefik.http.routers.${name}.entrypoints=web"
      "--label=traefik.http.services.${name}.loadbalancer.server.port=3000"
    )
    if [[ "${ENABLE_TLS:-0}" -eq 1 ]]; then
      labels+=(
        "--label=traefik.http.routers.${name}-secure.rule=PathPrefix(\`$prefix\`)"
        "--label=traefik.http.routers.${name}-secure.entrypoints=websecure"
        "--label=traefik.http.routers.${name}-secure.tls=true"
        "--label=traefik.http.services.${name}-secure.loadbalancer.server.port=3000"
      )
      labels+=("--label=traefik.http.routers.${name}-secure.tls.certresolver=myresolver")
    fi
  fi

  # Emit all labels as separate tokens for docker run
  printf '%s ' "${labels[@]}"
}

run_container() {
  local name="$1"
  local cname
  cname="$(container_name "$name")"
  local save_dir="$INST_DIR/$name/config"
  mkdir -p "$save_dir"

  local kvm_args=()
  if [[ "${ENABLE_KVM:-0}" -eq 1 && -e /dev/kvm ]]; then
    kvm_args=("--device=/dev/kvm" "--security-opt" "seccomp=unconfined")
  else
    kvm_args=("--security-opt" "seccomp=unconfined")
  fi

  local subfolder="/"
  if [[ "${NO_TRAEFIK}" -ne 1 ]]; then
    if [[ -z "${BLOBEVM_DOMAIN:-}" || -n "$(get_meta "$name" path_override || true)" || -n "$(get_meta "$name" host_override || true)" ]]; then
      local pfx
      pfx="$(get_meta "$name" path_override || true)"
      local base_path="${BASE_PATH:-/vm}"; [[ "$base_path" != /* ]] && base_path="/$base_path"; base_path="${base_path%/}"
      if [[ -n "$pfx" ]]; then
        [[ "$pfx" != /* ]] && pfx="/$pfx"
        [[ "$pfx" != */ ]] && pfx="$pfx/"
        subfolder="$pfx"
      else
        subfolder="${base_path}/${name}/"
      fi
      [[ "$subfolder" != /* ]] && subfolder="/$subfolder"
    elif [[ "${MERGED_MODE:-0}" -eq 1 ]]; then
      # In merged single-port mode, always serve under base path for consistency
      local base_path="${BASE_PATH:-/vm}"; [[ "$base_path" != /* ]] && base_path="/$base_path"; base_path="${base_path%/}"
      subfolder="${base_path}/${name}/"
      [[ "$subfolder" != /* ]] && subfolder="/$subfolder"
    fi
  fi

  local publish_args=()
  local net_args=()
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    # Determine and persist a host port for this VM (reassign if busy)
    local host_port
    host_port="$(get_meta "$name" host_port || true)"
    if [[ -n "$host_port" && $(port_in_use "$host_port"; echo $?) -eq 0 ]]; then
      # Port is currently in use (maybe by stale container); try to free by removing same-name container, else choose new
      local cname
      cname="$(container_name "$name")"
      docker rm -f "$cname" >/dev/null 2>&1 || true
    fi
    if [[ -z "$host_port" || $(port_in_use "$host_port"; echo $?) -eq 0 ]]; then
      host_port="$(find_free_port "${DIRECT_PORT_START}" 1000 || true)"
      if [[ -z "$host_port" ]]; then
        echo "Unable to find a free port to expose VM '$name'." >&2
        exit 1
      fi
      set_meta "$name" host_port "$host_port"
    fi
    publish_args=( -p "${host_port}:3000" )
  else
    net_args=( --network "${TRAEFIK_NETWORK:-proxy}" )
  fi

  docker run -d \
    --name "$cname" \
    --restart unless-stopped \
    $(limits_flags "$name") \
    -e PUID="$(id -u)" -e PGID="$(id -g)" \
    -e TZ=Etc/UTC \
    -e SUBFOLDER="$subfolder" \
    -e TITLE="BlobeVM - ${name}" \
    --shm-size="2gb" \
    -v "$save_dir":/config \
    ${publish_args[@]:-} \
    ${net_args[@]:-} \
    ${kvm_args[@]} \
    $(common_labels "$name") \
    "${BLOBEVM_IMAGE:-blobevm:latest}" \
    >/dev/null
}

# Resource limits helpers
limits_flags() {
  local name="$1"
  local cpu mem args=()
  cpu="$(get_meta "$name" cpu_limit || true)"
  mem="$(get_meta "$name" mem_limit || true)"
  if [[ -n "$cpu" ]]; then args+=("--cpus" "$cpu"); fi
  if [[ -n "$mem" ]]; then args+=("--memory" "$mem"); fi
  echo "${args[@]:-}"
}

cmd_set_limits() {
  local name="$1" cpu="$2" mem="$3"
  [[ -z "$name" || -z "$cpu" || -z "$mem" ]] && usage
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  set_meta "$name" cpu_limit "$cpu"
  set_meta "$name" mem_limit "$mem"
  recreate_container "$name"
  echo "Limits set for '$name' -> CPU: $cpu, Memory: $mem"
}

cmd_clear_limits() {
  local name="$1"; [[ -z "$name" ]] && usage
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  del_meta "$name" cpu_limit || true
  del_meta "$name" mem_limit || true
  recreate_container "$name"
  echo "Limits cleared for '$name'"
}

cmd_list() {
  ensure_instance_dir
  echo "Instances:"
  shopt -s nullglob
  for d in "$INST_DIR"/*; do
    if [[ -d "$d" ]]; then
      local name
      name="$(basename "$d")"
      local cname
      cname="$(container_name "$name")"
      local st
      st=$(docker ps --format '{{.Names}} {{.Status}}' | awk -v n="$cname" '$1==n{print $0}')
      [[ -z "$st" ]] && st="${cname} (stopped)"
      if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
        local hp
        hp="$(get_meta "$name" host_port || true)"
        [[ -n "$hp" ]] && st="${st} (port ${hp})"
      fi
      echo "- $name -> ${st} -> $(vm_url "$name")"
    fi
  done
}

cmd_create() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  ensure_instance_dir
  if instance_exists "$name"; then
    echo "Instance '$name' already exists." >&2
    exit 1
  fi
  mkdir -p "$INST_DIR/$name"
  # Preseed default config if available and target dir empty
  local save_dir="$INST_DIR/$name/config"
  mkdir -p "$save_dir"
  if [[ -n "${REPO_DIR:-}" && -d "${REPO_DIR}/root/config" ]] && [[ -z "$(ls -A "$save_dir" 2>/dev/null)" ]]; then
    cp -a "${REPO_DIR}/root/config/." "$save_dir/" 2>/dev/null || true
  fi
  run_container "$name"
  if [[ "$?" -ne 0 ]]; then
    # Best-effort: if port collision occurred in direct mode, reassign and retry once
    if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
      local hp
      hp="$(find_free_port "${DIRECT_PORT_START}" 1000 || true)"
      if [[ -n "$hp" ]]; then
        set_meta "$name" host_port "$hp"
        run_container "$name"
      fi
    fi
  fi
  echo "Created VM '$name' at: $(vm_url "$name")"
}

cmd_start() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  ensure_instance_dir
  local cname
  cname="$(container_name "$name")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    docker start "$cname" >/dev/null
    echo "Started '$name': $(vm_url "$name")"
  else
    echo "No container for '$name'. Creating..."
    run_container "$name"
    echo "Started '$name': $(vm_url "$name")"
  fi
}

cmd_stop() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  local cname
  cname="$(container_name "$name")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    docker stop "$cname" >/dev/null || true
    echo "Stopped '$name'"
  else
    echo "Instance '$name' not found." >&2
    exit 1
  fi
}

cmd_restart() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local cname
  cname="$(container_name "$name")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    docker restart "$cname" >/dev/null || { echo "Failed to restart '$name'" >&2; exit 1; }
    echo "Restarted '$name': $(vm_url "$name")"
  else
    echo "No container for '$name'. Creating..."
    run_container "$name"
    echo "Started '$name': $(vm_url "$name")"
  fi
}

cmd_status() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  local cname st line
  cname="$(container_name "$name")"
  line=$(docker ps -a --format '{{.Names}} {{.Status}}' | awk -v n="$cname" '$1==n{print $0}')
  if [[ -z "$line" ]]; then
    echo "${name}: not found"
    exit 1
  fi
  st="${line#* }"
  if [[ -z "$st" ]]; then st="stopped"; fi
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    local hp; hp="$(get_meta "$name" host_port || true)"
    [[ -n "$hp" ]] && st="${st} (port ${hp})"
  fi
  echo "${name}: ${st}"
  echo "URL: $(vm_url "$name")"
}

cmd_check() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  local url
  url="$(vm_url "$name")"
  # Backend is already public and accessible, no need to check
  echo "OK - $url"; return 0
}

cmd_delete() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  local cname
  cname="$(container_name "$name")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    docker rm -f "$cname" >/dev/null || true
  fi
  rm -rf "$INST_DIR/$name"
  echo "Deleted '$name'"
}

cmd_delete_all_instances() {
  echo "This will remove ALL VM instances but keep Traefik and the image."
  read -rp "Type 'DELETE' to confirm: " confirm
  [[ "$confirm" == "DELETE" ]] || { echo "Aborted."; exit 1; }
  shopt -s nullglob
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local name cname
    name="$(basename "$d")"
    cname="$(container_name "$name")"
    if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
      docker rm -f "$cname" >/dev/null 2>&1 || true
    fi
    rm -rf "$d"
    echo "Deleted '$name'"
  done
}

cmd_rebuild_image() {
  local ctx="${REPO_DIR:-/opt/blobe-vm}"
  local image="${BLOBEVM_IMAGE:-blobevm:latest}"
  [[ -d "$ctx" ]] || { echo "REPO_DIR not found: $ctx" >&2; exit 1; }
  echo "Building image '$image' from $ctx ..."
  docker build -t "$image" "$ctx"
  echo "Pruning dangling images and build cache..."
  docker image prune -f >/dev/null 2>&1 || true
  docker builder prune -af >/dev/null 2>&1 || true
}

cmd_recreate_all() {
  ensure_instance_dir
  echo "Recreating all VM containers..."
  shopt -s nullglob
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    recreate_container "$n"
    echo "Recreated '$n': $(vm_url "$n")"
  done
}

cmd_rebuild_all() {
  cmd_rebuild_image
  cmd_recreate_all
}

cmd_update_vm() {
  local name="$1"; [[ -z "$name" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local cname; cname="$(container_name "$name")"
  if ! docker ps --format '{{.Names}}' | grep -qx "$cname"; then
    echo "Container for '$name' not running; starting..."
    cmd_start "$name" >/dev/null
  fi
  echo "Updating packages inside '$name'..."
  docker exec -u 0 "$cname" bash -lc 'export DEBIAN_FRONTEND=noninteractive; apt-get update && apt-get -y dist-upgrade && apt-get -y autoremove && apt-get -y autoclean'
  echo "Done."
}

_copy_app_script_into_vm() {
  local cname="$1" app="$2"
  local host_script="${REPO_DIR:-/opt/blobe-vm}/root/installable-apps/${app}.sh"
  [[ -f "$host_script" ]] || { echo "App script not found: $app" >&2; return 2; }
  docker cp "$host_script" "$cname:/tmp/app-${app}.sh"
  docker exec -u 0 "$cname" bash -lc "chmod +x /tmp/app-${app}.sh"
}

cmd_app_install() {
  local name="$1" app="$2"
  [[ -z "$name" || -z "$app" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local cname; cname="$(container_name "$name")"
  if ! docker ps --format '{{.Names}}' | grep -qx "$cname"; then
    echo "Container for '$name' not running; starting..."
    cmd_start "$name" >/dev/null
  fi
  echo "Installing app '$app' in '$name'..."
  _copy_app_script_into_vm "$cname" "$app" || { echo "No installer for '$app'" >&2; exit 1; }
  docker exec -u 0 "$cname" bash -lc "/tmp/app-${app}.sh"
  echo "Installed '$app' in '$name'."
}

cmd_app_status() {
  local name="$1" app="$2"
  [[ -z "$name" || -z "$app" ]] && usage
  local cname; cname="$(container_name "$name")"
  if ! docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    echo "not-installed"; return 0
  fi
  # crude checks per known app
  local bin=""
  case "$app" in
    chrome|google-chrome|google-chrome-stable) bin="/usr/bin/google-chrome" ;;
    firefox) bin="/usr/bin/firefox" ;;
    vlc) bin="/usr/bin/vlc" ;;
    vscodium|code) bin="/usr/bin/codium" ;;
    steam) bin="/usr/games/steam" ;;
    discord) bin="/usr/bin/discord" ;;
    spotify|spotify-client) bin="/usr/bin/spotify" ;;
    *) bin="" ;;
  esac
  if [[ -n "$bin" ]]; then
    if docker exec "$cname" bash -lc "test -x '$bin'"; then
      echo "installed"; else echo "missing"; fi
  else
    echo "unknown"; return 0
  fi
}

# Map app name to likely apt/dpkg package names for removal
_app_packages_for() {
  local app="$1"
  case "$app" in
    chrome|google-chrome|google-chrome-stable) echo "google-chrome-stable" ;;
    discord) echo "discord" ;;
    vlc) echo "vlc" ;;
    vscodium|codium|code) echo "codium" ;;
    steam) echo "steam steam-launcher" ;;
    minecraft|minecraft-launcher) echo "minecraft-launcher" ;;
    synaptic) echo "synaptic" ;;
    aqemu) echo "aqemu" ;;
    xarchiver) echo "xarchiver" ;;
    wine|wine64) echo "wine*" ;;
    openjdk-17-jre) echo "openjdk-17-jre" ;;
    openjdk-8-jre) echo "openjdk-8-jre" ;;
    spotify|spotify-client) echo "spotify-client" ;;
    *) echo "" ;;
  esac
}

_app_uninstall_cleanup_script() {
  local app="$1"
  case "$app" in
    chrome|google-chrome|google-chrome-stable)
      cat <<'CLEAN'
set -e
rm -f /etc/apt/sources.list.d/google-chrome.list || true
rm -f /etc/apt/keyrings/google-chrome.gpg || true
CLEAN
      ;;
    vscodium|codium|code)
      cat <<'CLEAN'
set -e
rm -f /etc/apt/sources.list.d/vscodium.list || true
rm -f /usr/share/keyrings/vscodium-archive-keyring.gpg || true
CLEAN
      ;;
    spotify|spotify-client)
      cat <<'CLEAN'
set -e
rm -f /etc/apt/sources.list.d/spotify.list || true
rm -f /etc/apt/keyrings/spotify.gpg || true
CLEAN
      ;;
    *) : ;;
  esac
}

cmd_app_uninstall() {
  local name="$1" app="$2"
  [[ -z "$name" || -z "$app" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local cname; cname="$(container_name "$name")"
  if ! docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    echo "Container for '$name' not running; starting..."
    cmd_start "$name" >/dev/null
  fi
  local pkgs; pkgs="$(_app_packages_for "$app")"
  if [[ -z "$pkgs" ]]; then
    echo "Unknown app: $app" >&2; exit 1
  fi
  echo "Uninstalling app '$app' in '$name' (packages: $pkgs)..."
  # Build uninstall script to run inside the container as root
  local script
  script="$(mktemp)"
  {
    echo "export DEBIAN_FRONTEND=noninteractive"
    echo "apt-get update || true"
    echo "apt-get -y purge $pkgs || apt-get -y remove $pkgs || true"
    _app_uninstall_cleanup_script "$app"
    echo "apt-get -y autoremove || true"
    echo "apt-get -y autoclean || true"
  } >"$script"
  docker cp "$script" "$cname:/tmp/uninstall-$app.sh"
  docker exec -u 0 "$cname" bash -lc "chmod +x /tmp/uninstall-$app.sh && /tmp/uninstall-$app.sh" || {
    echo "Uninstall failed for '$app'" >&2; rm -f "$script"; exit 1; }
  rm -f "$script"
  echo "Uninstalled '$app' from '$name'."
}

cmd_app_reinstall() {
  local name="$1" app="$2"
  [[ -z "$name" || -z "$app" ]] && usage
  cmd_app_uninstall "$name" "$app" || true
  cmd_app_install "$name" "$app"
}

cmd_recreate_targets() {
  ensure_instance_dir
  [[ "$#" -ge 1 ]] || { echo "Usage: blobe-vm-manager recreate <name> [name2 ...]" >&2; exit 1; }
  for n in "$@"; do
    instance_exists "$n" || { echo "Instance '$n' not found" >&2; continue; }
    recreate_container "$n"
    echo "Recreated '$n': $(vm_url "$n")"
  done
}

cmd_rebuild_vms() {
  [[ "$#" -ge 1 ]] || { echo "Usage: blobe-vm-manager rebuild-vms <name> [name2 ...]" >&2; exit 1; }
  cmd_rebuild_image || exit $?
  cmd_recreate_targets "$@"
}

cmd_pull_repo() {
  local ctx="${REPO_DIR:-/opt/blobe-vm}"
  if [[ -d "$ctx/.git" ]] && command -v git >/dev/null 2>&1; then
    echo "Updating repo at $ctx ..."
    git -C "$ctx" pull --rebase --autostash || git -C "$ctx" pull
  else
    echo "No git repository found at $ctx; skipping."
  fi
}

cmd_update_and_rebuild() {
  if [[ "$#" -eq 0 ]]; then
    cmd_pull_repo
    cmd_rebuild_all
  else
    local targets=("$@")
    cmd_pull_repo
    cmd_rebuild_image
    cmd_recreate_targets "${targets[@]}"
  fi
}

# --- metadata helpers ---
meta_file() { echo "$INST_DIR/$1/instance.json"; }

get_meta() {
  local name="$1" key="$2"
  local mf
  mf="$(meta_file "$name")"
  [[ -f "$mf" ]] || return 0
  jq -r --arg k "$key" 'if has($k) then .[$k] else empty end' "$mf"
}

set_meta() {
  local name="$1" key="$2" val="$3"
  local mf tmp
  mf="$(meta_file "$name")"
  mkdir -p "$(dirname "$mf")"
  if [[ -f "$mf" ]]; then
    tmp="$(mktemp)"
    jq --arg k "$key" --arg v "$val" '.[$k]=$v' "$mf" > "$tmp" && mv "$tmp" "$mf"
  else
    printf '{"%s":"%s"}\n' "$key" "$val" > "$mf"
  fi
}

del_meta() {
  local name="$1" key="$2"
  local mf tmp
  mf="$(meta_file "$name")"
  [[ -f "$mf" ]] || return 0
  tmp="$(mktemp)"
  jq --arg k "$key" 'del(.[$k])' "$mf" > "$tmp" && mv "$tmp" "$mf"
}

recreate_container() {
  local name="$1"
  local cname
  cname="$(container_name "$name")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
    docker rm -f "$cname" >/dev/null || true
  fi
  # In direct mode, if stored host_port is now busy, pick a new one
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    local hp
    hp="$(get_meta "$name" host_port || true)"
    if [[ -z "$hp" || $(port_in_use "$hp"; echo $?) -eq 0 ]]; then
      local np
      np="$(find_free_port "${DIRECT_PORT_START}" 1000 || true)"
      [[ -n "$np" ]] && set_meta "$name" host_port "$np"
    fi
  fi
  run_container "$name"
}

cmd_rename() {
  local old="${1:-}" new="${2:-}"
  [[ -z "$old" || -z "$new" ]] && usage
  [[ "$old" == "$new" ]] && { echo "Old and new names are the same." >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$old" || { echo "Instance '$old' does not exist." >&2; exit 1; }
  if instance_exists "$new"; then
    echo "Target instance name '$new' already exists." >&2
    exit 1
  fi
  # Remove old container if present
  local oldc
  oldc="$(container_name "$old")"
  if docker ps -a --format '{{.Names}}' | grep -qx "$oldc"; then
    docker rm -f "$oldc" >/dev/null || true
  fi
  # Move instance directory
  mv "$INST_DIR/$old" "$INST_DIR/$new"
  # If no explicit path override exists (path mode), URL path will change automatically
  # Host override (domain mode) will keep using custom host if set
  run_container "$new"
  echo "Renamed '$old' -> '$new'"
  echo "New URL: $(vm_url "$new")"
}

cmd_set_host() {
  local name="${1:-}" host="${2:-}"
  [[ -z "$name" || -z "$host" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  set_meta "$name" host_override "$host"
  recreate_container "$name"
  echo "Updated host for '$name' -> $(vm_url "$name")"
}

cmd_clear_host() {
  local name="${1:-}"
  [[ -z "$name" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  del_meta "$name" host_override || true
  recreate_container "$name"
  echo "Cleared host override for '$name' -> $(vm_url "$name")"
}

cmd_set_path() {
  local name="${1:-}" prefix="${2:-}"
  [[ -z "$name" || -z "$prefix" ]] && usage
  [[ -z "${BLOBEVM_DOMAIN:-}" ]] || { echo "set-path is only for no-domain/path mode." >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  # Normalize to leading slash, trailing slash preserved via SUBFOLDER
  [[ "$prefix" != /* ]] && prefix="/$prefix"
  set_meta "$name" path_override "$prefix"
  recreate_container "$name"
  echo "Updated path for '$name' -> $(vm_url "$name")"
}

cmd_clear_path() {
  local name="${1:-}"
  [[ -z "$name" ]] && usage
  [[ -z "${BLOBEVM_DOMAIN:-}" ]] || { echo "clear-path is only for no-domain/path mode." >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  del_meta "$name" path_override || true
  recreate_container "$name"
  echo "Cleared path override for '$name' -> $(vm_url "$name")"
}

cmd_list_ports() {
  [[ "${NO_TRAEFIK}" -eq 1 ]] || { echo "list-ports is only available in direct mode (NO_TRAEFIK=1)." >&2; exit 1; }
  ensure_instance_dir
  echo "Ports:"
  shopt -s nullglob
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local name hp
    name="$(basename "$d")"
    hp="$(get_meta "$name" host_port || true)"
    echo "- ${name}: ${hp:-<unassigned>}"
  done
}

cmd_port() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  [[ "${NO_TRAEFIK}" -eq 1 ]] || { echo "port is only available in direct mode (NO_TRAEFIK=1)." >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local hp
  hp="$(get_meta "$name" host_port || true)"
  if [[ -z "$hp" ]]; then
    echo "<unassigned>"; exit 0
  fi
  echo "$hp"
}

cmd_set_port() {
  local name="${1:-}" port="${2:-}"
  [[ -z "$name" || -z "$port" ]] && usage
  [[ "${NO_TRAEFIK}" -eq 1 ]] || { echo "set-port is only available in direct mode (NO_TRAEFIK=1)." >&2; exit 1; }
  [[ "$port" =~ ^[0-9]+$ && "$port" -ge 1 && "$port" -le 65535 ]] || { echo "Invalid port: $port" >&2; exit 1; }
  if port_in_use "$port"; then
    echo "Port $port is already in use." >&2; exit 1
  fi
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  set_meta "$name" host_port "$port"
  recreate_container "$name"
  echo "Port set for '$name' -> $port"
  echo "URL: $(vm_url "$name")"
}

cmd_set_host_interactive() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  echo "Detected IP addresses:"
  ip -o -4 addr show | awk '{print "  "$2": "$4}'
  local pub
  pub=$(curl -fsS ifconfig.me || true)
  [[ -n "$pub" ]] && echo "  public: $pub"
  echo "Enter the DNS hostname (e.g., myvm.example.com or myvm.ddns.net) that you pointed to this server:"
  read -rp "Hostname: " host
  [[ -z "$host" ]] && { echo "No hostname entered." >&2; exit 1; }
  set_meta "$name" host_override "$host"
  recreate_container "$name"
  echo "Updated host for '$name' -> $(vm_url "$name")"
  echo "NOTE: Ensure DNS A record resolves to this server and port 80 is reachable for HTTPS issuance if enabled."
}

cmd_cf_expose() {
  # Expose a single VM through a Cloudflare tunnel using an ephemeral token.
  # Usage: blobe-vm-manager cf-expose <name> <public-hostname> <token>
  local name="$1" host="$2" token="$3"
  [[ -z "$name" || -z "$host" || -z "$token" ]] && { echo "Usage: blobe-vm-manager cf-expose <name> <public-hostname> <token>" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }

  # Resolve the local URL to forward
  local target
  target="$(vm_url "$name")"
  if [[ -z "$target" ]]; then
    echo "Unable to determine target URL for '$name'" >&2; exit 1
  fi

  # Prefer systemd-managed service when available
  if use_systemd; then
    # Ensure cloudflared binary exists
    if ! command -v cloudflared >/dev/null 2>&1; then
      echo "cloudflared not found â€” please install cloudflared binary (or run cf-setup in dashboard to use container mode)." >&2
      exit 1
    fi
    local svc_name="cloudflared-blobevm-${name}.service"
    local svc_path="/etc/systemd/system/${svc_name}"
    local exec_cmd
    exec_cmd="/usr/local/bin/cloudflared tunnel --no-autoupdate run --token '${token}' --url '${target}' --hostname '${host}'"
    cat > "$svc_path" <<EOF
[Unit]
Description=Cloudflared tunnel for BlobeVM instance ${name}
After=network.target

[Service]
Type=simple
ExecStart=${exec_cmd}
Restart=on-failure
User=root

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload || true
    systemctl enable --now "$svc_name" || { echo "Failed to enable/start $svc_name" >&2; exit 1; }
    sleep 1
    if systemctl is-active --quiet "$svc_name"; then
      echo "Cloudflared tunnel started for '$name' and should be available at: https://${host}/"
      return 0
    else
      echo "Service ${svc_name} failed to start. Check 'journalctl -u ${svc_name} -n 200' for details." >&2
      exit 1
    fi
  fi

  # Fallback: run cloudflared in a docker container (host network)
  ensure_cloudflared_state_dir
  local cname="cloudflared-blobevm-${name}"
  docker rm -f "$cname" >/dev/null 2>&1 || true
  echo "Starting cloudflared in docker container '$cname' (host networking)..."
  docker run -d --name "$cname" --net host --restart unless-stopped \
    cloudflare/cloudflared:latest tunnel --no-autoupdate run --token "$token" --url "$target" --hostname "$host" >/dev/null 2>&1 || {
    echo "Failed to start cloudflared container for '$name'" >&2; exit 1; }
  echo "Cloudflared container started for '$name' and should be available at: https://${host}/"
}

cmd_cf_setup() {
  # Interactive helper that walks through exposing a VM via Cloudflare tunnel.
  # Usage: blobe-vm-manager cf-setup [<name> <public-hostname> <token>]
  local name="${1:-}" host="${2:-}" token="${3:-}"
  if [[ -z "$name" ]]; then
    read -rp "Instance name to expose: " name || true
  fi
  if [[ -z "$host" ]]; then
    read -rp "Public hostname to assign (e.g. myvm.example.com): " host || true
  fi
  if [[ -z "$token" ]]; then
    read -rp "Cloudflare Tunnel token (ephemeral token): " token || true
  fi
  [[ -z "$name" || -z "$host" || -z "$token" ]] && { echo "Missing values; aborting." >&2; exit 1; }

  echo "Setting up Cloudflare tunnel for instance '$name' -> $host"
  cmd_cf_expose "$name" "$host" "$token"
}

cmd_cf_create_tunnel() {
  # Create a named tunnel and store credentials under CF_STATE_DIR
  # Usage: blobe-vm-manager cf-create-tunnel <tunnel-name>
  local tname="$1"
  [[ -z "$tname" ]] && { echo "Usage: blobe-vm-manager cf-create-tunnel <tunnel-name>" >&2; exit 1; }
  ensure_cloudflared_state_dir
  if command -v cloudflared >/dev/null 2>&1; then
    (cd "$CF_STATE_DIR" && cloudflared tunnel create "$tname") || { echo "Failed to create tunnel with cloudflared binary." >&2; exit 1; }
    echo "Created tunnel '$tname' and wrote credentials to $CF_STATE_DIR"; return 0
  fi
  # Fallback: try docker run to create tunnel (requires docker and cloudflared image)
  if command -v docker >/dev/null 2>&1; then
    docker run --rm -v "$CF_STATE_DIR":/etc/cloudflared -w /etc/cloudflared cloudflare/cloudflared:latest tunnel create "$tname" || { echo "Failed to create tunnel in docker container." >&2; exit 1; }
    echo "Created tunnel '$tname' (docker) and wrote credentials to $CF_STATE_DIR"; return 0
  fi
  echo "cloudflared binary or docker required to create named tunnel." >&2; exit 1
}

cmd_cf_remove() {
  # Remove a single-instance cloudflared service/container
  # Usage: blobe-vm-manager cf-remove <name>
  local name="$1"; [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager cf-remove <name>" >&2; exit 1; }
  local svc_name="cloudflared-blobevm-${name}"
  if use_systemd; then
    systemctl stop "${svc_name}.service" >/dev/null 2>&1 || true
    systemctl disable "${svc_name}.service" >/dev/null 2>&1 || true
    rm -f /etc/systemd/system/${svc_name}.service >/dev/null 2>&1 || true
    systemctl daemon-reload || true
    echo "Stopped and removed systemd service ${svc_name}.service"
  else
    docker rm -f "$svc_name" >/dev/null 2>&1 || true
    echo "Removed docker container $svc_name"
  fi
  # Clear metadata
  del_meta "$name" cf_exposed || true
  del_meta "$name" cf_path || true
  del_meta "$name" cf_tunnel_host || true
  del_meta "$name" cf_tunnel_name || true
}

# --- Merged-tunnel helpers (single Cloudflared tunnel, multiple ingress rules) ---
regenerate_cf_merged_config() {
  # Build /etc/cloudflared/blobevm.yml from instances marked with cf_exposed=merged
  local cfg_dir="/etc/cloudflared"
  local cfg_file="$cfg_dir/blobevm.yml"
  mkdir -p "$cfg_dir"
  # Determine tunnel host: prefer metadata on any merged instance, else BLOBEVM_DOMAIN
  local merge_host="${BLOBEVM_DOMAIN:-}"
  shopt -s nullglob
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    local ex; ex="$(get_meta "$n" cf_exposed || true)"
    if [[ "$ex" == "merged" ]]; then
      local h; h="$(get_meta "$n" cf_tunnel_host || true)"
      if [[ -n "$h" ]]; then merge_host="$h"; break; fi
    fi
  done
  if [[ -z "$merge_host" ]]; then
    echo "No merged tunnel host configured (BLOBEVM_DOMAIN or cf_tunnel_host required)." >&2
    return 1
  fi
  # Determine server/public host to use for backend targets (skip Docker IPs)
  local server_host
  server_host="$(resolve_public_host)"
  # Start YAML
  cat > "$cfg_file" <<YAML
proxy_address: ${server_host}
ingress:
YAML
  # Append ingress entries
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    local ex; ex="$(get_meta "$n" cf_exposed || true)"
    if [[ "$ex" == "merged" ]]; then
      local pfx; pfx="$(get_meta "$n" cf_path || true)"
      [[ -z "$pfx" ]] && pfx="/vm/${n}"
      [[ "$pfx" != /* ]] && pfx="/$pfx"
      # Determine an explicit loopback backend for reliability.
      # - Direct (NO_TRAEFIK=1): use per-instance host_port metadata (assign if missing)
      # - Traefik mode: forward to Traefik HTTP port on localhost (HTTP_PORT, default 80)
      local target_port=""
      if [[ "${NO_TRAEFIK:-0}" -eq 1 ]]; then
        target_port="$(get_meta "$n" host_port || true)"
        if [[ -z "$target_port" ]]; then
          # Try to assign a port if one isn't persisted yet
          target_port="$(find_free_port "${DIRECT_PORT_START}" 1000 || true)"
          [[ -n "$target_port" ]] && set_meta "$n" host_port "$target_port"
        fi
      else
        target_port="${HTTP_PORT:-80}"
      fi
      if [[ -z "$target_port" ]]; then
        # fallback to 3000 (container internal) if no port could be determined
        target_port=3000
      fi
  local target="http://${server_host}:${target_port}"
      # cloudflared will route requests for hostname+path to this backend; path is preserved by ingress
      cat >> "$cfg_file" <<YAML
  - hostname: ${merge_host}
    path: ${pfx}
    service: "${target}"
YAML
    fi
  done
  # fallback
  cat >> "$cfg_file" <<'YAML'
  - service: http_status:404
YAML
  echo "Wrote merged cloudflared config: $cfg_file"
}

cmd_cf_merge_add() {
  # Add an ingress mapping for a VM to the central merged tunnel config
  # Usage: blobe-vm-manager cf-merge-add <name> <path-prefix> <tunnel-host> [tunnel-name]
  local name="$1" path_prefix="$2" tunnel_host="$3" tunnel_name="${4:-blobevm}"
  [[ -z "$name" || -z "$path_prefix" || -z "$tunnel_host" ]] && { echo "Usage: blobe-vm-manager cf-merge-add <name> <path-prefix> <tunnel-host> [tunnel-name]" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  # Validate backend is reachable before adding merged rule
  local pfx="$path_prefix"
  [[ "$pfx" != /* ]] && pfx="/$pfx"
  # Determine backend port similarly to regenerate_cf_merged_config
  local target_port=""
  if [[ "${NO_TRAEFIK:-0}" -eq 1 ]]; then
    # Try persisted host_port first
    target_port="$(get_meta "$name" host_port || true)"
    if [[ -z "$target_port" ]]; then
      # If container exists, try docker port mapping
      local cname
      cname="$(container_name "$name")"
      if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
        target_port="$(docker port "$cname" 3000 2>/dev/null | sed -n 's/.*:\([0-9]\+\)$/\1/p' || true)"
        if [[ -n "$target_port" ]]; then set_meta "$name" host_port "$target_port"; fi
      fi
    fi
  else
    target_port="${HTTP_PORT:-80}"
  fi
  if [[ -z "$target_port" ]]; then
    echo "Unable to determine backend port for '$name'. Start the VM or ensure a port is assigned before adding merged mapping." >&2
    exit 1
  fi
  # Test backend using server/public host (not loopback or Docker IP)
  local test_url
  # Ensure trailing slash on path
  [[ "$pfx" != */ ]] && pfx="$pfx/"
  local server_host
  server_host="$(resolve_public_host)"
  test_url="http://${server_host}:${target_port}${pfx}"
  echo "Checking backend at ${test_url} ..."
  if command -v curl >/dev/null 2>&1; then
    code=$(curl -sS -m 5 -L -o /dev/null -w '%{http_code}' "$test_url" || echo "000")
  else
    # Use python one-liner as fallback
    code=$(python3 - <<PY - "$test_url"
import sys, urllib.request
url=sys.argv[1]
try:
    r=urllib.request.urlopen(url, timeout=5)
    print(r.getcode())
except Exception:
    print('000')
PY
)
  fi
  if [[ ! "$code" =~ ^[23][0-9][0-9]$ ]]; then
    echo "Backend check failed (HTTP ${code}) for ${test_url}. Not adding merged mapping." >&2
    exit 1
  fi

  set_meta "$name" cf_exposed "merged"
  set_meta "$name" cf_path "$path_prefix"
  set_meta "$name" cf_tunnel_host "$tunnel_host"
  set_meta "$name" cf_tunnel_name "$tunnel_name"
  regenerate_cf_merged_config || { echo "Failed to write merged config." >&2; exit 1; }
  # Ensure central service: prefer systemd, otherwise run docker container reading config from $CF_STATE_DIR
  local cfg_file="/etc/cloudflared/blobevm.yml"
  if use_systemd; then
    local svc_name="cloudflared-blobevm-merged.service"
    local svc_path="/etc/systemd/system/${svc_name}"
    local exec_cmd="/usr/local/bin/cloudflared tunnel --config '${cfg_file}' run '${tunnel_name}'"
    cat > "$svc_path" <<EOF
[Unit]
Description=Cloudflared merged tunnel for BlobeVM
After=network.target

[Service]
Type=simple
ExecStart=${exec_cmd}
Restart=on-failure
User=root
WorkingDirectory=/etc/cloudflared

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload || true
    systemctl enable --now "$svc_name" || { echo "Failed to enable/start $svc_name" >&2; exit 1; }
    echo "Added merged ingress for '$name' -> ${tunnel_host}${path_prefix} and started merged tunnel service."
  else
    ensure_cloudflared_state_dir
    # write merged config into CF_STATE_DIR so container can mount it
    mkdir -p "$CF_STATE_DIR" || true
    cp -f /etc/cloudflared/blobevm.yml "$CF_STATE_DIR/blobevm.yml" 2>/dev/null || cp -f "$CFG_FILE" "$CF_STATE_DIR/blobevm.yml" 2>/dev/null || true
    local cname="cloudflared-blobevm-merged"
    docker rm -f "$cname" >/dev/null 2>&1 || true
    echo "Starting cloudflared merged tunnel in docker container '$cname' (host networking)..."
    docker run -d --name "$cname" --net host --restart unless-stopped -v "$CF_STATE_DIR":/etc/cloudflared:ro \
      cloudflare/cloudflared:latest tunnel --config /etc/cloudflared/blobevm.yml run "$tunnel_name" >/dev/null 2>&1 || { echo "Failed to start merged cloudflared container" >&2; exit 1; }
    echo "Merged cloudflared container started for host ${tunnel_host}. Paths registered for instance '$name'."
  fi
}

cmd_cf_merge_remove() {
  # Remove merged ingress for a VM
  # Usage: blobe-vm-manager cf-merge-remove <name>
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager cf-merge-remove <name>" >&2; exit 1; }
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  del_meta "$name" cf_exposed || true
  del_meta "$name" cf_path || true
  del_meta "$name" cf_tunnel_host || true
  del_meta "$name" cf_tunnel_name || true
  # Rebuild config
  if ! regenerate_cf_merged_config; then
    # If no merged entries remain, disable service and remove config
    local svc_name="cloudflared-blobevm-merged"
    if use_systemd; then
      systemctl stop "${svc_name}.service" >/dev/null 2>&1 || true
      systemctl disable "${svc_name}.service" >/dev/null 2>&1 || true
      rm -f /etc/cloudflared/blobevm.yml >/dev/null 2>&1 || true
    else
      docker rm -f "$svc_name" >/dev/null 2>&1 || true
      rm -f "$CF_STATE_DIR/blobevm.yml" >/dev/null 2>&1 || true
    fi
    echo "Removed merged ingress for '$name' and stopped merged tunnel (no merged entries remain)."
    return 0
  fi
  # Otherwise reload/restart the merged service
  if use_systemd; then
    systemctl restart cloudflared-blobevm-merged.service || true
  else
    docker rm -f cloudflared-blobevm-merged >/dev/null 2>&1 || true
    # restart container with updated config
    docker run -d --name cloudflared-blobevm-merged --net host --restart unless-stopped -v "$CF_STATE_DIR":/etc/cloudflared:ro \
      cloudflare/cloudflared:latest tunnel --config /etc/cloudflared/blobevm.yml run "${tunnel_name:-blobevm}" >/dev/null 2>&1 || true
  fi
  echo "Removed merged ingress for '$name' and reloaded merged tunnel service."
}

cmd_cf_merge_list() {
  echo "Merged Cloudflare ingress mappings:"
  shopt -s nullglob
  local found=0
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    local ex; ex="$(get_meta "$n" cf_exposed || true)"
    if [[ "$ex" == "merged" ]]; then
      local pfx; pfx="$(get_meta "$n" cf_path || true)"
      local host; host="$(get_meta "$n" cf_tunnel_host || true)"
      local tn; tn="$(get_meta "$n" cf_tunnel_name || true)"
      echo "- $n -> ${host}${pfx} (tunnel: ${tn:-blobevm})"
      found=1
    fi
  done
  [[ "$found" -eq 0 ]] && echo "  <none>"
}

# --- Per-VM tunnel helpers (create/delete/status/recreate) -----------------
cmd_tunnel_create() {
  # Create a per-VM named tunnel, persist credentials to /etc/blobe/tunnels/<vm>.json,
  # save tunnel_id and mark status in instance metadata.
  # Usage: blobe-vm-manager tunnel-create <vm-name>
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager tunnel-create <vm-name>" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  ensure_cloudflared_state_dir
  local tname="blobevm-${name}"
  local outdir="/etc/blobe/tunnels"
  mkdir -p "$outdir"
  # Try local cloudflared binary first
  if command -v cloudflared >/dev/null 2>&1; then
    (cd "$CF_STATE_DIR" && cloudflared tunnel create "$tname") || { echo "cloudflared tunnel create failed" >&2; exit 1; }
  elif command -v docker >/dev/null 2>&1; then
    docker run --rm -v "$CF_STATE_DIR":/etc/cloudflared -w /etc/cloudflared cloudflare/cloudflared:latest tunnel create "$tname" || { echo "docker cloudflared tunnel create failed" >&2; exit 1; }
  else
    echo "cloudflared binary or docker required to create tunnel." >&2; exit 1
  fi
  # Find most-recent credentials file under CF_STATE_DIR
  local cred
  cred=$(ls -t "$CF_STATE_DIR"/*.json 2>/dev/null | head -n1 || true)
  if [[ -z "$cred" || ! -f "$cred" ]]; then
    echo "Unable to locate created tunnel credentials in $CF_STATE_DIR" >&2; exit 1
  fi
  # Copy credentials to outdir with vm-name.json
  cp -f "$cred" "$outdir/${name}.json" || { echo "Failed to copy credentials to $outdir" >&2; exit 1; }
  chmod 600 "$outdir/${name}.json" || true
  # Try to extract tunnel id from the credential JSON
  local tid
  if command -v jq >/dev/null 2>&1; then
    tid=$(jq -r '.TunnelID // .Tunnel.ID // .tunnel_id // .id // .Tunnel.ID' "$outdir/${name}.json" 2>/dev/null || true)
  else
    tid=$(grep -Eo '"(TunnelID|id|tunnel_id)"\s*:\s*"[0-9a-fA-F-]+"' "$outdir/${name}.json" 2>/dev/null | head -n1 | sed -E 's/.*:\s*"([^"]+)"/\1/' || true)
  fi
  # Persist metadata
  if [[ -n "$tid" && "$tid" != "null" ]]; then
    set_meta "$name" tunnel_id "$tid"
  fi
  set_meta "$name" tunnel_name "$tname"
  set_meta "$name" tunnel_status "created"
  # If a global domain is configured, also set a default cf_tunnel_host for convenience
  if [[ -n "${BLOBEVM_DOMAIN:-}" ]]; then
    set_meta "$name" cf_tunnel_host "${name}.${BLOBEVM_DOMAIN}"
  fi
  # Try to register DNS route and run the tunnel (best-effort)
  local host=""
  host=$(get_meta "$name" cf_tunnel_host || true)
  if [[ -z "$host" && -n "${BLOBEVM_DOMAIN:-}" ]]; then
    host="${name}.${BLOBEVM_DOMAIN}"
    set_meta "$name" cf_tunnel_host "$host"
  fi
  # Determine backend port: direct mode use host_port metadata, otherwise HTTP_PORT
  local backend_port=""
  if [[ "${NO_TRAEFIK:-0}" -eq 1 ]]; then
    backend_port=$(get_meta "$name" host_port || true)
  fi
  if [[ -z "$backend_port" ]]; then
    backend_port="${HTTP_PORT:-80}"
  fi
  # Determine server/public host to use for runtime --url targets (skip Docker IPs)
  local server_host
  server_host="$(resolve_public_host)"
  # Persist public-facing service URL so the dashboard can show it
  set_meta "$name" cf_service_url "http://${server_host}:${backend_port}/"
  # Register DNS route (requires cloudflared binary or docker)
  if [[ -n "$host" ]]; then
    # Attempt to create DNS route and capture output for error reporting
    local route_out=""; local route_rc=0
    if command -v cloudflared >/dev/null 2>&1; then
      route_out=$(cd "$CF_STATE_DIR" && cloudflared tunnel route dns "$tname" "$host" 2>&1) || route_rc=$?
    elif command -v docker >/dev/null 2>&1; then
      route_out=$(docker run --rm -v "$CF_STATE_DIR":/etc/cloudflared -w /etc/cloudflared cloudflare/cloudflared:latest tunnel route dns "$tname" "$host" 2>&1) || route_rc=$?
    else
      route_out="cloudflared binary or docker not available"
      route_rc=127
    fi
    if [[ $route_rc -ne 0 ]]; then
      # Persist route error for dashboard visibility
      set_meta "$name" tunnel_status "created:route-error"
      # truncate error to 1000 chars to avoid huge metadata
      local routetxt
      routetxt=$(printf "%s" "$route_out" | sed -n '1,200p')
      set_meta "$name" tunnel_route_error "$routetxt"
      echo "Warning: DNS route creation failed for ${name}: ${routetxt}" >&2
    else
      set_meta "$name" tunnel_status "created:route-ok"
      set_meta "$name" tunnel_route_error ""
    fi
  fi
  # If user provided CF_API_TOKEN, attempt to create DNS record via Cloudflare API
  if [[ -n "${CF_API_TOKEN:-}" && -n "$host" ]]; then
    # Try to obtain the tunnel's CF DNS cname from cloudflared list
    local list_json=""
    if command -v cloudflared >/dev/null 2>&1; then
      list_json=$(cd "$CF_STATE_DIR" && cloudflared tunnel list --output json 2>/dev/null || true)
    elif command -v docker >/dev/null 2>&1; then
      list_json=$(docker run --rm -v "$CF_STATE_DIR":/etc/cloudflared -w /etc/cloudflared cloudflare/cloudflared:latest tunnel list --output json 2>/dev/null || true)
    fi
    local tunnel_cname=""
    if [[ -n "$list_json" ]]; then
      tunnel_cname=$(printf "%s" "$list_json" | python3 - <<PY 2>/dev/null
import sys, json
try:
    data=json.load(sys.stdin)
    for x in data:
        if x.get('name') == '${tname}':
            cfdns = x.get('cfdns') or {}
            if isinstance(cfdns, dict):
                print(cfdns.get('cname') or '')
            elif isinstance(cfdns, list) and len(cfdns) > 0:
                print(cfdns[0].get('cname',''))
            else:
                print('')
            break
except Exception:
    pass
PY
)
    fi
    if [[ -n "$tunnel_cname" ]]; then
      # Determine zone to use for DNS record
      local zone_name="${BLOBEVM_DOMAIN:-}"
      if [[ -z "$zone_name" ]]; then
        # Fallback: derive zone by stripping first label
        zone_name=$(echo "$host" | awk -F. '{print $(NF-1)"."$NF}')
      fi
      if [[ -n "$zone_name" ]]; then
        # Find zone id via Cloudflare API
        local zone_api_out
        zone_api_out=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=${zone_name}&status=active" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json") || true
        local zone_id
        zone_id=$(printf "%s" "$zone_api_out" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('result',[{}])[0].get('id',''))" 2>/dev/null || true)
        if [[ -n "$zone_id" ]]; then
          # Create DNS CNAME record pointing host -> tunnel_cname
          local create_out
          create_out=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json" --data '{"type":"CNAME","name":"'"$host"'","content":"'"$tunnel_cname"'","ttl":120,"proxied":true}') || true
          local create_ok
          create_ok=$(printf "%s" "$create_out" | python3 -c "import sys,json; d=json.load(sys.stdin); print('1' if d.get('success') else '0')" 2>/dev/null || true)
          if [[ "$create_ok" == "1" ]]; then
            set_meta "$name" tunnel_dns_ok "1"
            set_meta "$name" tunnel_dns_error ""
          else
            set_meta "$name" tunnel_dns_ok "0"
            # store a short snippet of create_out
            local ctxt
            ctxt=$(printf "%s" "$create_out" | sed -n '1,200p')
            set_meta "$name" tunnel_dns_error "$ctxt"
            echo "Warning: DNS API create returned error for ${name}: ${ctxt}" >&2
          fi
        else
          set_meta "$name" tunnel_dns_ok "0"
          set_meta "$name" tunnel_dns_error "Unable to find zone id for ${zone_name}"
          echo "Warning: Unable to find zone id for ${zone_name}" >&2
        fi
      fi
    fi
  fi
  # Start a runtime cloudflared service/container for this tunnel (host network) so it proxies to local backend
  local svc_name="cloudflared-blobevm-${name}"
  if use_systemd; then
    # Create a simple systemd service that runs the tunnel
    local svc_path="/etc/systemd/system/${svc_name}.service"
    local exec_cmd="/usr/local/bin/cloudflared tunnel --no-autoupdate run --url 'http://${server_host}:${backend_port}' '${tname}'"
    cat > "$svc_path" <<EOF
[Unit]
Description=Cloudflared tunnel for BlobeVM instance ${name}
After=network.target

[Service]
Type=simple
ExecStart=${exec_cmd}
Restart=on-failure
User=root
WorkingDirectory=/etc/cloudflared

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload || true
    systemctl enable --now "$svc_name" >/dev/null 2>&1 || true
    # Check runtime status
    if systemctl is-active --quiet "$svc_name"; then
      set_meta "$name" tunnel_status "active"
      set_meta "$name" tunnel_runtime_error ""
    else
      set_meta "$name" tunnel_status "runtime-error"
      # capture recent journal entries for the service
      local jr
      jr=$(journalctl -u "$svc_name" -n 200 --no-pager 2>/dev/null || true)
      jr=$(printf "%s" "$jr" | sed -n '1,200p')
      set_meta "$name" tunnel_runtime_error "$jr"
      echo "Warning: cloudflared service failed to start for ${name}. Journal: ${jr}" >&2
    fi
  else
    ensure_cloudflared_state_dir
    docker rm -f "$svc_name" >/dev/null 2>&1 || true
    local drun
    drun=$(docker run -d --name "$svc_name" --net host --restart unless-stopped -v "$CF_STATE_DIR":/etc/cloudflared:ro \
      cloudflare/cloudflared:latest tunnel --no-autoupdate run --url "http://${server_host}:${backend_port}" "${tname}" 2>&1) || true
    if [[ "$drun" =~ ^[0-9a-fA-F]+$ ]]; then
      set_meta "$name" tunnel_status "active"
      set_meta "$name" tunnel_runtime_error ""
    else
      set_meta "$name" tunnel_status "runtime-error"
      drun=$(printf "%s" "$drun" | sed -n '1,200p')
      set_meta "$name" tunnel_runtime_error "$drun"
      echo "Warning: cloudflared docker container failed to start for ${name}: ${drun}" >&2
    fi
  fi
  echo "Created tunnel for '$name' -> credentials: $outdir/${name}.json (tunnel: ${tname}) (host: ${host}, backend: ${backend_port})"
}

cmd_tunnel_delete() {
  # Delete tunnel credentials and stop related runtime container/service
  # Usage: blobe-vm-manager tunnel-delete <vm-name>
  local name="$1"
  [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager tunnel-delete <vm-name>" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local outdir="/etc/blobe/tunnels"
  local svc_name="cloudflared-blobevm-${name}"
  if use_systemd; then
    systemctl stop "${svc_name}.service" >/dev/null 2>&1 || true
    systemctl disable "${svc_name}.service" >/dev/null 2>&1 || true
  else
    docker rm -f "$svc_name" >/dev/null 2>&1 || true
  fi
  rm -f "$outdir/${name}.json" || true
  del_meta "$name" tunnel_id || true
  del_meta "$name" tunnel_name || true
  del_meta "$name" tunnel_status || true
  echo "Removed tunnel for '$name'"
}

cmd_tunnel_status() {
  # Report tunnel metadata
  # Usage: blobe-vm-manager tunnel-status <vm-name>
  local name="$1"; [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager tunnel-status <vm-name>" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  local mf
  mf="$(meta_file "$name")"
  if [[ -f "$mf" ]]; then
    if command -v jq >/dev/null 2>&1; then
      jq -r '{tunnel_id: .tunnel_id, tunnel_name: .tunnel_name, tunnel_status: .tunnel_status, cf_tunnel_host: .cf_tunnel_host, cf_exposed: .cf_exposed} | tojson' "$mf" 2>/dev/null || cat "$mf"
    else
      cat "$mf"
    fi
    return 0
  fi
  echo "{}"
}

cmd_tunnel_recreate() {
  # Recreate (regenerate) credentials and restart runtime container for the VM tunnel
  # Usage: blobe-vm-manager tunnel-recreate <vm-name>
  local name="$1"; [[ -z "$name" ]] && { echo "Usage: blobe-vm-manager tunnel-recreate <vm-name>" >&2; exit 1; }
  ensure_instance_dir
  instance_exists "$name" || { echo "Instance '$name' does not exist." >&2; exit 1; }
  # Delete existing then create anew
  cmd_tunnel_delete "$name"
  cmd_tunnel_create "$name"
}

cmd_set_base_path() {
  local base="${1:-}"; [[ -z "$base" ]] && usage
  [[ "$base" != /* ]] && base="/$base"
  base="${base%/}"
  BASE_PATH="$base"
  # Update global .env
  if [[ -f /opt/blobe-vm/.env ]]; then
    sed -i -E "s|^BASE_PATH=.*|BASE_PATH=$BASE_PATH|" /opt/blobe-vm/.env || echo "BASE_PATH=$BASE_PATH" >> /opt/blobe-vm/.env
  fi
  echo "Base path set to $BASE_PATH. Recreating running containers..."
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    recreate_container "$n"
  done
}

# --- URL helpers ---
dashboard_url() {
  local ip http_port https_port https_suffix http_suffix
  ip="$(resolve_public_host)"
  http_port="${HTTP_PORT:-80}"; https_port="${HTTPS_PORT:-443}"
  http_suffix=""; https_suffix=""
  [[ "$http_port" != "80" ]] && http_suffix=":"$http_port
  [[ "$https_port" != "443" ]] && https_suffix=":"$https_port
  if [[ "${NO_TRAEFIK}" -eq 1 ]]; then
    if [[ -n "${DASHBOARD_PORT:-}" ]]; then
      echo "http://${ip}:${DASHBOARD_PORT}/dashboard"; return
    fi
    echo "(dashboard disabled or unknown port)"; return
  fi
  if [[ -n "${BLOBEVM_DOMAIN:-}" ]]; then
    if [[ "${ENABLE_TLS:-0}" -eq 1 ]]; then
      echo "https://dashboard.${BLOBEVM_DOMAIN}${https_suffix}/"; return
    else
      echo "http://dashboard.${BLOBEVM_DOMAIN}${http_suffix}/"; return
    fi
  else
    echo "http://${ip}${http_suffix}/dashboard"; return
  fi
}

open_browser() {
  local url="$1"
  if [[ -n "${BROWSER:-}" ]]; then
    "${BROWSER}" "$url" >/dev/null 2>&1 && return 0
  fi
  if command -v xdg-open >/dev/null 2>&1; then xdg-open "$url" >/dev/null 2>&1 && return 0; fi
  if command -v sensible-browser >/dev/null 2>&1; then sensible-browser "$url" >/dev/null 2>&1 && return 0; fi
  if command -v gio >/dev/null 2>&1; then gio open "$url" >/dev/null 2>&1 && return 0; fi
  return 1
}

cmd_url() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  echo "$(vm_url "$name")"
}

cmd_open() {
  local name="${1:-}"; [[ -z "$name" ]] && usage
  local url
  url="$(vm_url "$name")"
  echo "$url"
  open_browser "$url" || echo "Note: couldn't auto-open a browser on this host."
}

cmd_dashboard_url() {
  dashboard_url
}

cmd_open_dashboard() {
  local url
  url="$(dashboard_url)"
  echo "$url"
  open_browser "$url" || echo "Note: couldn't auto-open a browser on this host."
}

cmd_clear_base_path() {
  BASE_PATH="/vm"
  if [[ -f /opt/blobe-vm/.env ]]; then
    sed -i -E "s|^BASE_PATH=.*|BASE_PATH=/vm|" /opt/blobe-vm/.env || echo "BASE_PATH=/vm" >> /opt/blobe-vm/.env
  fi
  echo "Base path reset to /vm. Recreating running containers..."
  for d in "$INST_DIR"/*; do
    [[ -d "$d" ]] || continue
    local n; n="$(basename "$d")"
    recreate_container "$n"
  done
}

main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    list)   cmd_list "$@" ;;
    list-ports) cmd_list_ports "$@" ;;
    create) cmd_create "$@" ;;
    start)  cmd_start "$@" ;;
    stop)   cmd_stop "$@" ;;
    restart) cmd_restart "$@" ;;
    status) cmd_status "$@" ;;
    check)  cmd_check "$@" ;;
    delete) cmd_delete "$@" ;;
  delete-all-instances) cmd_delete_all_instances "$@" ;;
    rename) cmd_rename "$@" ;;
    set-host) cmd_set_host "$@" ;;
    clear-host) cmd_clear_host "$@" ;;
    set-path) cmd_set_path "$@" ;;
    clear-path) cmd_clear_path "$@" ;;
    port)   cmd_port "$@" ;;
    set-port) cmd_set_port "$@" ;;
    url)    cmd_url "$@" ;;
    open)   cmd_open "$@" ;;
    dashboard-url) cmd_dashboard_url "$@" ;;
    open-dashboard) cmd_open_dashboard "$@" ;;
    cf-expose) cmd_cf_expose "$@" ;;
    cf-setup) cmd_cf_setup "$@" ;;
    cf-merge-add) cmd_cf_merge_add "$@" ;;
    cf-merge-remove) cmd_cf_merge_remove "$@" ;;
    cf-merge-list) cmd_cf_merge_list "$@" ;;
  tunnel-create) cmd_tunnel_create "$@" ;;
  tunnel-delete) cmd_tunnel_delete "$@" ;;
  tunnel-status) cmd_tunnel_status "$@" ;;
  tunnel-recreate) cmd_tunnel_recreate "$@" ;;
  rebuild-image) cmd_rebuild_image "$@" ;;
  recreate-all) cmd_recreate_all "$@" ;;
  recreate) cmd_recreate_targets "$@" ;;
  rebuild-all) cmd_rebuild_all "$@" ;;
  rebuild-vms) cmd_rebuild_vms "$@" ;;
  pull-repo) cmd_pull_repo "$@" ;;
  update-and-rebuild) cmd_update_and_rebuild "$@" ;;
    nuke)   cmd_nuke "$@" ;;
    set-host-interactive) cmd_set_host_interactive "$@" ;;
    set-base-path) cmd_set_base_path "$@" ;;
    clear-base-path) cmd_clear_base_path "$@" ;;
  set-limits) cmd_set_limits "$@" ;;
  clear-limits) cmd_clear_limits "$@" ;;
  app-install) cmd_app_install "$@" ;;
  app-status) cmd_app_status "$@" ;;
  app-uninstall) cmd_app_uninstall "$@" ;;
  app-reinstall) cmd_app_reinstall "$@" ;;
    *) usage ;;
  esac
}

cmd_nuke() {
  echo "This will remove ALL BlobeVM instances, BlobeVM dashboard, Traefik stack (if deployed by BlobeVM), data, images, related volumes, and the manager binary."
  read -rp "Type 'NUKE' to confirm: " confirm
  if [[ "$confirm" != "NUKE" ]]; then
    echo "Aborted."
    exit 1
  fi

  echo "Stopping and removing instance containers..."
  shopt -s nullglob
  local cname
  for cname in $(docker ps -a --format '{{.Names}}' | grep -E '^blobevm_' || true); do
    docker rm -f "$cname" >/dev/null 2>&1 || true
  done

  echo "Removing BlobeVM dashboard containers (blobedash, blobedash-proxy) if present..."
  for cname in blobedash blobedash-proxy; do
    if docker ps -a --format '{{.Names}}' | grep -qx "$cname"; then
      docker rm -f "$cname" >/dev/null 2>&1 || true
    fi
  done

  echo "Bringing down Traefik stack if deployed by BlobeVM..."
  if [[ -f /opt/blobe-vm/traefik/docker-compose.yml ]]; then
    (cd /opt/blobe-vm/traefik && docker compose down --remove-orphans) || true
  fi

  echo "Removing BlobeVM images (all tags under repository 'blobevm')..."
  docker images --format '{{.Repository}}:{{.Tag}}' | awk -F: '$1=="blobevm" {print $0}' | xargs -r docker rmi -f >/dev/null 2>&1 || true

  echo "Removing proxy network if empty..."
  if docker network inspect proxy >/dev/null 2>&1; then
    # Only remove if no containers attached
    local attached
    attached=$(docker network inspect proxy -f '{{ len .Containers }}') || attached=1
    if [[ "$attached" == "0" ]]; then
      docker network rm proxy >/dev/null 2>&1 || true
    fi
  fi

  echo "Removing BlobeVM-related Docker volumes (best-effort)..."
  docker volume ls --format '{{.Name}}' | grep -Ei '(blobevm|blobe-vm|blobedash|blobe)' | xargs -r docker volume rm >/dev/null 2>&1 || true

  echo "Removing data directory /opt/blobe-vm ..."
  rm -rf /opt/blobe-vm

  echo "Removing manager binary /usr/local/bin/blobe-vm-manager ..."
  rm -f /usr/local/bin/blobe-vm-manager

  echo "Done. BlobeVM resources removed (no global Docker prune performed)."
}

main "$@"
